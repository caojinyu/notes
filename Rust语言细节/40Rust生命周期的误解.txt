1、T是&T和&mut T的超集， &T和&mut T是不相交的集合。
2、T：'static应该被读作T受'static生命周期约束。
3、如果T：'static，那么T可以是一个有着'static生命周期的借用类型，或者一个所有权类型。
4、既然T：'static包含了所有权类型，那么意味着T
          （1）：可以在运行时动态分配。
          （2）：不必在整个程序中都是有效的。
          （3）：可以被安全的任意修改。
          （4）：可以在运行时动态析构。
          （5）：可以有不同长度的生命周期。
5、T：'static比&'a T更泛化、灵活。
6、T：'a接受所有权类型、带引用的所有权类型，以及引用。
7、&'a T只接受引用。
8、如果T：'static 那么T：'a，因为对于所有'a都有'static >= 'a
9、几乎所有的Rust代码都是泛型的，到处都有省略的生命周期。
10、 Rust的生命周期省略规则并不是任何情况下都对。
11、Rust并不比你更了解你程序的语义。
12、给生命周期标记起一个有描述性的名字。
13、考虑清楚哪里需要显示写出生命周期标记，以及为什么要这么写。
14、所有trait object都有默认推断的生命周期约束。
15、Rust的编译错误信息可以让你的代码通过编译，但不一定是最符合你代码要求的。
16、生命周期是在编译器静态验证的。
17、生命周期不会以任何方式在运行时变长缩短。
18、Rust的借用检查总会为每个变量选择一个最短可能的生命周期，
    并且假定每条代码路径都会被执行。
19、尽量避免将可变引用重新借用为不可变引用，不然你会遇到不少麻烦。
20、重新借用一个可变引用不会终止它的生命周期，即使这个可变引用已经析构。
21、每个语言都有自己的小陷阱。

装箱的trait的生命周期推断：
（1）如果一个trait对象作为一个类型参数传递到泛型中，那么它的生命约束会从它包含的类型中推断。
      如果包含的类型中有唯一的约束，那么就使用这个约束。
      如果包含的类型中有超过一个约束，那么必须显示指定约束。
（2）如果以上都不适用， 那么
    如果trait是以单个生命周期约束定义的，那么就使用这个约束。
    如果所有生命周期约束都是'static的，那么就使用'static.
    如果trait没有生命周期约束，那么它的生命周期将会从表达式中推断，如果
       不在表达式中，那么就是'static的。
use std::cell::Ref;

trait Trait {}

// 省略
type T1 = Box<dyn Trait>;
// 展开，Box<T>对T没有生命周期约束，所以被推断为'static
type T2 = Box<dyn Trait + 'static>;

// 省略
impl dyn Trait {}
// 展开
impl dyn Trait + 'static {}

// 省略
type T3<'a> = &'a dyn Trait;
// 展开, 因为&'a T 要求 T: 'a, 所以推断为 'a
type T4<'a> = &'a (dyn Trait + 'a);

// 省略
type T5<'a> = Ref<'a, dyn Trait>;
// 展开, 因为Ref<'a, T> 要求 T: 'a, 所以推断为 'a
type T6<'a> = Ref<'a, dyn Trait + 'a>;

trait GenericTrait<'a>: 'a {}

// 省略
type T7<'a> = Box<dyn GenericTrait<'a>>;
// 展开
type T8<'a> = Box<dyn GenericTrait<'a> + 'a>;

// 省略
impl<'a> dyn GenericTrait<'a> {}
// 展开
impl<'a> dyn GenericTrait<'a> + 'a {}
